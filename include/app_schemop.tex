\autoref{table:schemop_cmd} shows a list of directives currently
supported by the ScheMo Preprocessor.

Each directive is identified by a string name (shown in the first
column of the table\footnote{When present, a number between square
brackets is used to distinguish between different uses of the same
identifier, but it is not to be considered part of the name}) that is
used in conjunction with a prefix to be recognized by \code{schemop}.
There are two default prefixes:
\begin{itemize}
  \item a \textit{full prefix}: \code{@SCHEMO\_}
  \item a \textit{shorthand prefix}: \code{@}
\end{itemize}
The desired prefix (either one of the default ones or a user-defined
one) can be selected using a command-line option of \cmdline{schemop}.

In the table, the usage strings are written using the shorthand
prefix for brevity, but they apply to any other prefix as well.

Inside the usage strings, italicized names are to be replaced with
suitable to get the desired result. 

\def \cmddescwidth {0.7\textwidth}
\begin{longtable}{lp{\cmddescwidth}}
\addcaption{2}{table:schemop_cmd}
\\
\textbf{Directive}
& \textbf{Usage and description}
\\ \hline

\hline
\endhead

\addcaption{2}{table:schemop_cmd}

\endfoot

\endlastfoot

\tablesection{2}{\textit{Automatic code generation}}

\code{DECLARE} &
\code{@DECLARE}

Must be placed in the global space before any other directive.

The preprocessor replaces it with the declarations of all the
variables and functions needed to make the code generated by the other
directives work.
\\ \hline
\code{INIT} &
\code{@INIT}

Must be used before any scheduling occurs.

It initializes all needed variables and the scheduler itself.
\\ \hline
\code{SCHEDULE\_ALL} &
\code{@SCHEDULE\_ALL}

Shortcut command to schedule all recognized jobs. Jobs that have been
defined without the use of the ScheMo Preprocessor are not automatically
scheduled this way.

To schedule jobs individually the C++ function
\code{schemo::schedule\_job(\variable{name})} can be used.
\\ \hline \hline

\tablesection{2}{\textit{Job definition}}

\code{JOB[1]} &
\code{@JOB (\variable{name}) \{\variable{code}\}}

Defines a new job called \variable{name}. The \variable{code} part
contains the definition of the job similarly to a normal C++ function,
with the added possibility to use special \cmdline{schemop} directives.
\\ \hline
\code{JOB[2]} &
\code{@JOB \{\variable{code}\}}

Like the one above, but the job name is autogenerated by the
preprocessor. Because of this, the job can only be scheduled by using
the \code{@SCHEDULE\_ALL} directive.
\\ \hline
\code{JDELAY} &
\code{@JDELAY (\variable{delay})}

If used, it must be placed inside a \code{JOB} block.

Defines how many cycles the job must skip between the execution of one
of its task and the next. It can be useful if some tasks need to get
control less often than others to work properly.

If this directive is not used, a \variable{delay} of \code{0} is assumed
(meaning that no cycles are skipped).
\\ \hline

\\ \hline \hline

\tablesection{2}{\textit{Control flow%
\footnote{\label{job_inside_note}%
These directives can only be used inside \code{JOB} and
\code{FUNCTION} blocks.
}}}

\code{TBREAK[1]} &
\code{@TBREAK (\variable{name})}

Explicitly ends a task and starts a new one called \variable{name}.

It's useful to add break-points where the scheduler can pass control to
a different job when long linear pieces of code without interruptions
are present.
\\ \hline
\code{TBREAK[2]} &
\code{@TBREAK}

Like the one above, but the task name is autogenerated.
\\ \hline
\code{WHILE[1]} &
\code{@WHILE (\variable{condition}) \{\variable{code}\}}

\cmdline{schemop}'s counterpart of a C++ \code{while} loop. The differences
with a normal C++ \code{while} loop are that:
\begin{itemize}
  \item a break-point is added before the first condition check and
  before each loop-back, meaning that control is passed to a different
  job after each iteration
  \item using other control flow directives or a \code{CALL} directive
  inside a normal C++ control flow statement would break it
\end{itemize}
\rule{0pt}{0pt}

\\ \hline
\code{WHILE[2]} &
\code{@WHILE \{\variable{code}\}}

Like the one above, but a \code{true} condition is assumed. It
effectively generates an infinite loop.
\\ \hline
\code{IF} &
\code{@IF (\variable{condition}) \{\variable{code}\}}

\cmdline{schemop}'s counterpart of a C++ \code{if} statement. The reasons
to use it instead of a normal C++ \code{if} are similar to those in
favour of \code{WHILE} statements.
\\ \hline
\code{ELSE} &
\code{@ELSE \{\variable{code}\}}

\cmdline{schemop}'s counterpart of a C++ \code{else} statement to be
used after an \code{IF} block instead of the standard C++ statement.
\\ \hline
\code{CONTINUE} &
\code{@CONTINUE}

\cmdline{schemop}'s counterpart of a C++ \code{continue} statement to be
used inside a \code{WHILE} block instead of the standard C++ statement.
\\ \hline
\code{BREAK} &
\code{@BREAK}

\cmdline{schemop}'s counterpart of a C++ \code{break} statement to be
used inside a \code{WHILE} block.
\\ \hline
\code{EXIT} &
\code{@EXIT}

Stops the execution of the current job.
\\ \hline
\code{SHUTDOWN} &
\code{@SHUTDOWN}

Stops the main scheduler loop and thus the execution of all scheduled
jobs.

\\ \hline \hline

\tablesection{2}{\textit{Memory management\footref{job_inside_note}}}

\code{MEMORY} &
\code{@MEMORY \{\variable{variables}\}}

Defines the variables available to all tasks of a job. Multiple
\code{MEMORY} blocks can be defined for the same job.

\variable{variable} is a list of \code{VAR[1]} directives.
\\ \hline
\code{VAR[1]} &
\code{@VAR (\variable{name} : \variable{type})}

Used inside a \code{MEMORY} block to declare a job-wide variable called
\variable{name} of type \variable{type}.
\\ \hline
\code{VAR[2]} &
\code{@VAR (\variable{name})}

Used outside a \code{MEMORY} block to refer to a previously declared
 ob-wide variable.
\\ \hline
\code{CRITSEC} &
\code{@CRITSEC (\variable{name}) \{\variable{code}\}}

Protects a block of code with a mutex called \variable{name} (defining
the latter if it is its first appearance in the code).
\\ \hline

\\ \hline \hline

\tablesection{2}{\textit{Functions}}

\code{FUNCTION} &
\code{@FUNCTION (\variable{name}) \variable{options} \{\variable{code}\}}

Defines a function that can be used with the \code{CALL} directive and
can contain control flow directives, similarly to a \code{JOB} block.

\variable{options} is a list of zero or more \code{PARAM[1]} directives
and exactly one \code{RETURN[1]} directive.
\\ \hline
\code{PARAM[1]} &
\code{@PARAM (\variable{name} : \variable{type})}

Defines a parameter for a function when placed among its
\variable{options}.

\variable{type} and \variable{name} represent respectively the type of
the related variable and the name with which it can be referenced inside
the function.
\\ \hline
\code{RETURN[1]} &
\code{@RETURN (\variable{type})}

Defines the type of variable returned by the function when placed among
its \variable{options}. ScheMo functions can not be declared
\code{void}.
\\ \hline
\code{PARAM[2]} &
\code{@PARAM (\variable{name})}

Used inside a function to refer to the parameter with the same name.
\\ \hline
\code{RETURN[2]} &
\code{@RETURN (\variable{value});}

Used inside a function to stop its execution and return \variable{value}
to the caller.
\\ \hline
\code{CALL[1]} &
\code{@CALL (\variable{function}) : \variable{result};}

Calls a ScheMo function with name \variable{function} without parameters
and places the returned value in a new variable called \variable{result}.

The type of the variable is inferred from the function definition.

\variable{result}'s scope is limited to a task that starts right after
the \code{CALL} statement.
\\ \hline
\code{CALL[2]} &
\code{@CALL (\variable{function} ; \variable{parameters}) : \variable{result};}

Like the one above, but semicolon-separated parameters are passed to the
function. The parameters must be passed in the same order with which
they were defined in the function's \variable{options}.
\\ \hline

\caption{List of ScheMo Preprocessor directives}
\label{table:schemop_cmd}

\end{longtable}
